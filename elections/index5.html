<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Add a geocoder</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
<script src='//unpkg.com/d3@5.0.0/dist/d3.min.js'></script>
<style>
  body { margin: 0; padding: 0; }
</style>
</head>
<body>
<div id="chart"></div>

<script>
  var canvasDim = { width: window.innerWidth, height: window.innerHeight}
  var margin = {top: 0, right: 0, bottom: 0, left: 0}
  var width = canvasDim.width - margin.left - margin.right 
  var height = canvasDim.height - margin.top - margin.bottom 

  var chart = d3.select("#chart")

  var svg = chart.append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)

  var g = svg.append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

  var map = g.append("g").attr("id", "map")
  var bubbles_explore = g.append("g").attr("id", "bubbles_explore")

  var centroids = []

  let radius = 18

  let forceCollide = d3.forceCollide()
      .radius(function(d) { return radius * 1.1; })

  function drawMap(data, projection) {

    var path = d3.geoPath()
       .projection(projection)

    // draw a path for each feature/country
    countriesPaths = map
       .selectAll("path")
       .data(data.features)
       .enter().append("path")
       .attr("d", path)
       .attr("class", "constituencies")
       .attr('fill', 'transparent')
       .attr('stroke', 'black')
       .attr('stroke-width', '0.4px')

    // store an array of each country's centroid
    data.features.map(d=> {
      centroids.push({
        name: d.properties["name"],
        x: path.centroid(d)[0],
        y: path.centroid(d)[1]
      })
    })

  }

  function drawClusters(data, projection) {

    data.forEach(d=>{
      let point = projection([+d['lat'], +d['long']])
      d.x = point[0]
      d.y = point[1]
    })

    var simulation = d3.forceSimulation()
      .nodes(data)
      .force("collide", forceCollide)
      .force('charge', d3.forceManyBody().strength(-10))
      .force("x", d3.forceX(function (d) { return d.x }))
      .force("y", d3.forceY(function (d) { return d.y }))

    simulateStatic(data, simulation)

  }

  function simulateStatic(nodes, simulation) {

    simulation.stop();

    while (simulation.alpha() > simulation.alphaMin()) {
      simulation.tick();
    }

    updateCircles(nodes)

  }

  function updateCircles(data){

    circles = bubbles_explore.selectAll("g.nodegroup").data(data, (d,i)=>d['key'])

    let entered_circles = circles.enter().append("g")
      .attr('class', 'nodegroup')
     
    const imageAccessor = d => `./images/${d.newName}.jpg`
    const fillAccessor = d => `url(#image-${d.newName})`

    const defs = entered_circles.append("defs");

    defs
      .append('pattern')
        .attr("id", d => "image-" + d['newName'])
        .attr("width", 1)
        .attr("height", 1)
      .append("svg:image")
        .attr("xlink:href", d => imageAccessor(d))
        .attr("width", 35)
        .attr("preserveAspectRatio", "xMidYMid slice");

    entered_circles.append("circle").attr('class', 'bubble')
      .attr('transform', d=> { return 'translate(' + d.x + "," + d.y + ")" })
      .attr('r', radius)
      .attr('stroke', 'black')
      .attr('stroke-width', '1px')
      .attr('stroke-opacity', 1)
      .attr('fill', d => fillAccessor(d))
      .attr('fill-opacity', 1)

    circles.merge(entered_circles).select('.bubble')         
      .transition().duration(1000)
      .attr('transform', d=> { return 'translate(' + d.x + "," + d.y + ")" })

    circles.exit()
      .transition().duration(750)
      .style('opacity', 0)
      .remove()
    
  }

  function drawArc(data) {

    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////// Create scales ///////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    var color = ["#E47D06", "#DB0131", "#AF0158", "#7F378D", "#3465A8", "#0AA174", "#7EB852", "#E47D06", "#DB0131", "#AF0158", "#7F378D", "#3465A8", "#0AA174", "#7EB852", "#E47D06", "#DB0131"]
    var category = ["Finance", "PMO", "Law", "Defence", "Culture, Community and Youth", "Education", "Foreign Affairs", "Communications & Information", "Health", "Home Affairs", "Manpower", "National Development", "Sustainability and the Environment", "Trade and Industry", "Transport", "Social & Family Development"]
    //Social policies
    //"Sustainability and Environment"
    //"Social and Family Development"
    // "Communications and Information"
    // "Culture, Community and Youth"
    // Education

    // Defence
    // Foreign Affairs

    // Health

    // Transport

    // Finance
    //"Trade and Industry"
    // "Manpower"

    // Law
    // "National Development"
    // Home Affairs

    //PMO
    var colorScale = d3.scaleOrdinal()
      .domain(category)
      .range(color)

    var Foci_new = onFociCountChange(category, 5)
    var FociText = onFociCountChange(category, 3.8)

    let dataFiltered = data.filter(d=>d['Type.1'] == 'Cabinet')
    let nodes = createNodes(Foci_new, dataFiltered) 
    updateTexts(FociText) 

    var simulation = d3.forceSimulation()
      .nodes(nodes)
      .force("collide", forceCollide)
      .force('charge', d3.forceManyBody().strength(-10))
      .force("x", d3.forceX(function (d) { return d.x }))
      .force("y", d3.forceY(function (d) { return d.y }))

    simulateStatic(nodes, simulation)

    // setTimeout(function(){

    //   let nodes = createNodes(Foci_new, data) 

    //   simulation = d3.forceSimulation()
    //     .nodes(nodes)
    //     .force("collide", forceCollide)
    //     .force('charge', d3.forceManyBody().strength(-10))
    //     .force("x", d3.forceX(function (d) { return d.x }))
    //     .force("y", d3.forceY(function (d) { return d.y }))

    //   simulateStatic(nodes, simulation)

    // }, 3000)

    ////////////////////// Assign focus point of each category //////////////////
    function onFociCountChange(focis, multiplier) {
        fociCount = focis.length
        foci = {};
        for (let i = 0; i < fociCount; i++) {
            let focus = createFocus(i, focis[i], fociCount, multiplier);
            foci[i] = focus;
        }
        let Foci_new = []
        Object.keys(foci).map(function(key, index) {
           Foci_new.push({
            x: foci[index].x,
            y: foci[index].y,
            key: foci[index].key,
            color: foci[index].color
          })     
        })
        return Foci_new
    }

    /////////////////////// Calculate focus point of each category ///////////////
    function createFocus(index, key, fociCount, multiplier) {
        let angle = 2 * Math.PI / fociCount * index;
        return {
            key: key,
            index: index,
            angle: angle,
            color: colorScale(key),
            x: width/multiplier * Math.cos(angle) + width/2,
            y: width/multiplier * Math.sin(angle) + height/2
        };
    }

    ////////////////////////////////// Create nodes //////////////////////////////
    function createNodes(focis, data) {

      var n = []
      data.map((d,i)=> {
        let F = focis.find(f=>f.key == d.Ministry_1) || [{x: width/2, y: height/2, color: "#E47D06"}]
        n.push({
          key: d['newName'] + '-' + d.Ministry_1, // unique index for each node
          r: 3,
          color: F.color,
          strokeFill: F.color,
          x: F.x,
          y: F.y,
          Name: d['Name'],
          newName: d['newName']
        })
      })
      let data_2 = data.filter(d=>d.Ministry_2)
      data_2.map((d,i)=> {
        let F = focis.find(f=>f.key == d.Ministry_2) || [{x: width/2, y: height/2, color: "#E47D06"}]
        n.push({
          key: d['newName'] + '-' + d.Ministry_2, // unique index for each node
          r: 3,
          color: F.color,
          strokeFill: F.color,
          x: F.x,
          y: F.y,
          Name: d['Name'],
          newName: d['newName']
        })
      })
      let data_3 = data.filter(d=>d.Ministry_3)
      data_3.map((d,i)=> {
        let F = focis.find(f=>f.key == d.Ministry_3) || [{x: width/2, y: height/2, color: "#E47D06"}]
        n.push({
          key: d['newName'] + '-' + d.Ministry_3, // unique index for each node
          r: 3,
          color: F.color,
          strokeFill: F.color,
          x: F.x,
          y: F.y,
          Name: d['Name'],
          newName: d['newName']
        })
      })

      return n

    }

    function updateTexts(focis) {
      texts = bubbles_explore.selectAll("text.fociText").data(focis, (d,i)=>d['key'])

      let entered_texts = texts.enter().append("text")
        .attr('class', 'fociText')
        .attr('transform', d=> { return 'translate(' + d.x + "," + d.y + ")" })
        .attr('text-align', 'center')
        .attr('color', 'black')
        .attr('font-size', '10px')
        .text(d=>d['key'])

      texts.merge(entered_texts)         
        .transition().duration(1000)
        .attr('transform', d=> { return 'translate(' + d.x + "," + d.y + ")" })

      texts.exit()
        .transition().duration(750)
        .style('opacity', 0)
        .remove()
    }

  }

  //Load data
  Promise.all([
    d3.csv("./data/mps_constituencies.csv"),
    d3.json("./data/electoral-boundary-2015.geojson")
  ]).then(function(data) {

    let data0 = data[0]
    let data1 = data[1]
    data0.forEach(d=>{
      d.key = d['newName'] + '-' + d.Ministry_1
    })

    let projection = d3.geoMercator()
        .center([103.851784, 1.287953]) 
        .scale(1)
        .fitSize([width*1.4, height*1.4], data1)
        .translate([width/2, height*(5/6)]) 
 
    //drawMap(data1, projection)
    drawClusters(data0, projection)

    setTimeout(function(){
      drawArc(data0)
    }, 2000)
   
  })

</script>

</body>
</html>