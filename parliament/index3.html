<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Add a geocoder</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
<script src='//unpkg.com/d3@5.0.0/dist/d3.min.js'></script>
<script src="https://d3js.org/d3-random.v2.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v1.9.1/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v1.9.1/mapbox-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/flubber@0.3.0"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/5.1.5/turf.min.js"></script>
<style>
  body { margin: 0; padding: 0; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }
  svg {
    position: absolute;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.5.1/mapbox-gl-geocoder.min.js"></script>
<link
    rel="stylesheet"
    href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.5.1/mapbox-gl-geocoder.css"
    type="text/css"
/>
<!-- Promise polyfill script required to use Mapbox GL Geocoder in IE 11 -->
<script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.min.js"></script>
<div id="map"></div>

<script>
  //mapboxgl.accessToken = 'pk.eyJ1IjoiZGlhbmFtZW93IiwiYSI6ImNqcmh4aWJnOTIxemI0NXA0MHYydGwzdm0ifQ.9HakB25m0HLT-uDY2yat7A';
    //var map = new mapboxgl.Map({
        //container: 'map',
        //style: 'mapbox://styles/mapbox/streets-v11',
        //center: [103.851784, 1.287953],
        //zoom: 10
    //});

    //map.addControl(
        //new MapboxGeocoder({
            //accessToken: mapboxgl.accessToken,
            //mapboxgl: mapboxgl
        //})
    //);

    //
    //Mapbox + D3 connection

    //Get mapbox map canvas container
    //var canvas = map.getCanvasContainer();

    //Overlay D3 on the map
    var svg = d3.select("#map").append("svg");


    //Projection function
    //var transform = d3.geoTransform({point:projectPoint});
    //var path = d3.geoPath().projection(transform);

    //Project geojson coordinate to the map's current state
    //function project(d) {
      //return map.project(new mapboxgl.LngLat(+d[0], +d[1]));
    //}

    //Project any point to map's current state
    //function projectPoint(lon, lat) {
      //var point = map.project(new mapboxgl.LngLat(lon, lat));
      //this.stream.point(point.x, point.y);
    //}

    //Load data
    Promise.all([
      d3.json("./data/GE2020_Constituencies.json"),
      d3.json("./data/electoral-boundary-2020.json")
    ]).then(function(data) {

      //
      // D3 stuff

      //Draw geojson data with d3
      var lines;

      let data0 = data[0]
      let data1 = data[1]

      data0.features.forEach(d=>{
        d.properties.votes_perc = d3.randomInt(20, 80)()
      })

      data1.features.forEach(d=>{
        d.properties.votes_perc = d3.randomInt(20, 80)()
      })

      const t = svg.transition()
          .duration(750);

      let fixed = data1.features.map(function(f) {
        return turf.rewind(f,{reverse:true});
      })
      
      var projection = d3.geoMercator()
        .fitSize([window.innerWidth, window.innerHeight],{"type": "FeatureCollection","features":fixed})

      var path = d3.geoPath()
         .projection(projection)

      var colorScale = d3.scaleSequential(d3.interpolateSpectral).domain([20, 80]);

      //Function for drawing the data
      function morphData(geojson, type) {

        lines = svg.selectAll("path").data(geojson.features, d=>findID(d))

        linesEntered = lines.enter().append("path")
          .attr("class", function(d) { return findID(d) })
          .attr("stroke", d => colorScale(d.properties.votes_perc))
          .attr("stroke-width", type==='big' ? 4 : 1)
          .attr("fill", d => colorScale(d.properties.votes_perc))
          .attr("fill-opacity", 0)
          .attr("d", path)

        // lines.merge(linesEntered)
        //   .attr("stroke", d => colorScale(d.properties.votes_perc))
        //   .attr("d", path)

        // lines.exit().remove()
      }

      morphData(data0, "subzone")
      morphData(data1, "big")
      //setTimeout(function(){
        //morphData(data1)
      //}, 5000)

      // d3.selectAll("path")
      //   .transition().duration(5000)
      //   .attrTween('d', function(d,i) { 
      //     let string1 = path(d)
      //     let string2 = path(data1.features.find(el=> findID(el) === findID(d))) || path(d)
      //     return flubber.interpolate(string1, string2) 
      //   })

      // let to_remove = []
      // data0.features.map(d=>{
      //   let tmp = data1.features.find(el=> findID(el) === findID(d)) ? 'found' : findID(d)
      //   if(tmp !== 'found'){
      //     to_remove.push(tmp)
      //   }
      // })

      // setTimeout(function(){
      //   d3.selectAll("path")
      //     .filter(d=>to_remove.indexOf(findID(d)) !== -1).remove()
      // }, 2000)

    })

    function findID(d){
      if(d.properties.Description){
        let grc = d.properties.Description.split(':')[1].split('<br>')[0].replace(/\s/g, '')
        let index = d.properties.Name.split('_')[1] || d.properties.Name.replace(/\s/g, '')
        return grc + '-' + index
      } else {
        return d.properties.Name
      }
    }

</script>

</body>
</html>